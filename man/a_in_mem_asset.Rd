% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/in_mem_asset.R
\name{a_in_mem_asset}
\alias{a_in_mem_asset}
\title{a_in_mem_asset()}
\usage{
a_in_mem_asset(data, ...)
}
\arguments{
\item{data}{a string containing file content or a list of such strings.}

\item{...}{additional parameters passed to `a_asset()`}
}
\value{
an asset object.
}
\description{
Create an A-Frame asset hosted in R's memory.
}
\details{
To understand this object you will almost certainly need to familiarise yourself with its base class 'A_Asset' first. See \code{\link{a_asset}}.

This function is used to create a special kind of A-Frame asset that is only
notionally backed by a file. The primary use of this is for passing CRAN's
vignette checks, testing, and demonstration. From the end-user's perspective
an in-memory-asset appears exactly like a regular asset file. However the
scene creates a route to `src` and `parts` that reference the contents of
`data` rather than files specified by the paths in `src` and `parts`.

An example usecase: Serving a JSON transform of an built-in R dataframe as an
asset without writing an intermediate JSON file to disk.

It is still necessary to supply a 'real looking' path to the asset. The path must be
relative to the current R working directory, but other than that is doesn't
matter what it is. The most important aspect of this notional path is the
file extension, since this is used to determine the HTTP mime-type header
when the asset is served.

`data` is either a length one character vector or a list of length one
character vectors. It must have the same length as the number of paths
supplied in `src` + `parts`. The character vectors are strings that contain
the entire contents of a notional file. For non-text files they would need
to contain the equivalent encoded text of calling readr::read_file_raw().
}
